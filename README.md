# Вопросов для собеседования на вакансию Python
Информация взята [отсюда](https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-bez-opyta) и [отсюда](https://kirill-sklyarenko.ru/lenta/150-voprosov-na-sobesedovanie-python-s-opytom-raboty)
# Без опыта работы
## Общие вопросы по Python с ответами

<details>
<summary><b>1. Основные фичи питона?</b></summary><br>

> Если питон оказался первым языком в опыте программирования, нужно иметь общее понимание о нем. Какие у него основные признаки:
>
> - это интерпретируемый язык
> - в нем динамическая типизация данных
> - это объектно-ориентированный язык
> - он лаконичный и внешне простой
> - распространяется бесплатно
> - у него большое сообщество
</details>


<details>
<summary><b>2. В чем разница между списками (list) и кортежами (tuple)?</b></summary>

>Основная разница в том, что список может изменяться (mutable), а кортеж не может (immutable).
```python
    >>> mylist = [1, 3, 3]
    >>> mylist[1] = 2
    >>> mytuple = (1, 3, 3)
    >>> mytuple[1] = 2
    Traceback (most recent call last):
    File “<pyshell#97>”, line 1, in
    mytuple[1] = 2
    TypeError: "tuple" object does not support item assignment
```
</details>


<details>
<summary><b>3. Как в питоне работает трёхместный (тернарный) оператор?</b></summary>

>*В питоне есть такие выражения:* `[если верно] if [выражение] else [если неверно]`
>
>*То есть, когда выражение верное (True), то исполняется код `[если верно]`. В остальных случаях исполняется код `[если неверно]`. Например:*

```python
>>> a, b = 2, 3
>>> min = a if a < b else b
>>> min
2

>>> print("Hi") if a < b else print("Bye")
Hi
```
</details>


<details>
<summary>4. Что такое отрицательный индекс (negative index)?</summary>

Возьмем для примера список:
```python
>>> mylist = [0, 1, 2, 3, 4, 5 ,6, 7, 8]
```
В отличие от положительного индекса отрицательный начинает поиск с конца:
```python
>>> mylist[-3]
6
```
Еще это помогает при создании срезов с конца:
```python
>>> mylist[-6:-1]
[3, 4, 5, 6, 7]
```
</details>


<details>
<summary>5. Питон чувствителен к регистру?</summary>

Язык считается чувствительным к регистру в случае, если он различает имена "myname" и "Myname". То есть, если он отслеживает разницу регистра (между верхним и нижним). Посмотрим, как с этим в питоне.

```python
>>> myname="Ayushi"
>>> Myname
Traceback (most recent call last):
File “<pyshell#3>”, line 1, in
Myname
NameError: name "Myname" is not defined
```
Убедились в том, что питон чувствителен к регистру.
</details>


<details>
<summary>6. Предельно допустимая длина идентификатора в питоне?</summary>

В питоне идентификатор может быть любой длины. Помимо этого есть несколько правил для присвоения имен:
- первым символом может быть нижнее подчеркивание (_), символы A-Z или a-z;
- остальная часть имени может состоять из символов A-Z/a-z/_/0-9;
- не забываем, что питон чувствителен к регистру;
- в качестве имени нельзя использовать ключевые слова (keywords):
```python
and, def, False, import, not, True, as, del, finally, in, or, try, assert, elif, for, is, pass, while, break, else, from, lambda, print, with, class, except, global, None, raise, yield, continue, exec, if, nonlocal, return.
```
</details>


<details>
<summary>7. Как можно преобразовать строку (string) в нижний регистр (lowercase)?</summary>

Для этого используется метод lower():
```python
>>> "AyuShi".lower()
"ayushi"
```
Для преобразования в верхний регистр (uppercase) используется метод upper():
```python
>>> "AyuShi".upper()
"AYUSHI"
```
Еще есть методы isupper() (все символы в верхнем регистре) и islower() (все символы в нижнем регистре), которые проверяют регистр всех символов имени.
```python
>>> "AyuShi".isupper()
False

>>> "AYUSHI".isupper()
True

>>> "ayushi".islower()
True

>>> "@yu$hi".islower()
True

>>> "@YU$HI".isupper()
True
```
Как видим, символы наподобие @ и $ применимы в обоих случаях.

Еще есть метод istitle(), который проверяет строку на стиль заголовка (все слова должны начинаться с символа в верхнем регистре):
```python
>>> "The Corpse Bride".istitle()
True
```
</details>


<details>
<summary>8. Для чего нужен pass (pass statement) в питоне?</summary>

Иногда нужно, чтобы код не давал никакого результата и не показывал ошибку, например, если еще не готово, но нужно иметь синтаксический корректный код. Можно поставить pass:
```python
>>> def func(*args):
        pass
```
Кроме него есть break (break statement), которое разрывает цикл:
```python
>>> for i in range(7):
        if i == 3: break
        print(i)
0
1
2
```
Наконец, есть continue (continue statement), которое перешагивает на следующую итерацию:
```python
>>> for i in range(7):
        if i==3: continue
        print(i)
0
1
2
4
5
6
```
</details>


## Часто задаваемые вопросы на собеседовании по Python с ответами (без опыта работы)


<details>
<summary>9. Расскажите про функции help() и dir() в питоне.</summary>

Функция help() показывает строку документации и справку для ее аргумента:
```python
>>> import copy
>>> help(copy.copy)
Help on function copy in module copy: # справка по функции copy в модуле copy:
copy(x)
Shallow copy operation on arbitrary Python objects. # операция поверхностного копирования для выбранного объекта питона.
See the module"s __doc__ string for more info. № # дополнительную информацию см. в строке __doc__ этого модуля.
```
Функция dir() возвращает список, содержащий пространство имен в объекте:
```python
>>> dir(copy.copy)
["__annotations__", "__call__", "__class__", "__closure__", "__code__", "__defaults__", "__delattr__", "__dict__", "__dir__", "__doc__", "__eq__", "__format__", "__ge__", "__get__", "__getattribute__", "__globals__", "__gt__", "__hash__", "__init__", "__init_subclass__", "__kwdefaults__", "__le__", "__lt__", "__module__", "__name__", "__ne__", "__new__", "__qualname__", "__reduce__", "__reduce_ex__", "__repr__", "__setattr__", "__sizeof__", "__str__", "__subclasshook__"]
```
</details>


<details>
<summary>10. Как получить список из всех ключей словаря (dictionary keys)?</summary>

На такие вопросы нужно отвечать детально, с примерами. Данная задача выполняется с помощью функции keys():
```python
>>> mydict={"a":1,"b":2,"c":3,"e":5}
>>> mydict.keys()
dict_keys(["a", "b", "c", "e"])
```
</details>


<details>
<summary>11. Что такое срез?</summary>

Срез — это методика, которая позволяет получить часть списка, кортежа или строки.
```python
>>> (1, 2, 3, 4, 5)[2:4]
(3, 4)

>>> [7, 6, 8, 5, 9][2:]
[8, 5, 9]

>>> "Hello"[:-1]
"Hell"
```
</details>


<details>
<summary>12. Как пишутся комментарии в питоне?</summary>

Для этого используется символ #. Все, что написано на строке после него, считается комментарием и игнорируется. Комментарии используются для объяснения цели написанного кода. Многострочных комментариев в прямом смысле слова в питоне нет.
```python
>>> # первая строка комментария
>>> # вторая строка комментария
```
</details>


<details>
<summary>13. Как проверить, что все символы строки относятся к алфавитно-цифровым?</summary>

Для этого используется метод isalnum().
```python
>>> ''.isalnum()  
False
>>> '  '.isalnum()
False
>>> '!@#'.isalnum()
False
>>> 'abc'.isalnum()
True
>>> '123'.isalnum()
True
>>> 'abc123'.isalnum()
True
```
</details>


<details>
<summary>14. Как перевести первый символ строки в верхний регистр?</summary>

Для этого есть метод capitalize():
```python
>>> "ayushi".capitalize()
"Ayushi"
```
</details>


<details>
<summary>15. Все знают, что сегодня питон в моде. Но истинное принятие новой технологии подразумевает понимание ее недостатков. Что вы можете сказать по этому поводу?</summary>

Какие в питоне есть ограничения:
 - интерпретируемая природа питона снижает скорость исполнения программы
 - его не выгодно использовать для мобильных устройств и браузеров
 - будучи языком с динамической типизацией данных, он использует утиную типизацию; в связи с этим появляются ошибки исполнения (runtime errors);
 - в нем слабо развиты возможности доступа к базам данных; поэтому питон не идеальный вариант для приложений с очень большими базами данных;
 - низкие требования на входе, то есть свои силы в питоне может попробовать каждый; это иногда снижает качество кода;
 - у питона индивидуально выраженный стиль.
</details>


<details>
<summary>16. Как в питоне узнать, в какой мы сейчас директории?</summary>

Для этого используется функция getcwd(). Она импортируется из модуля os:
```python
>>> import os
>>> os.getcwd()
"C:\\Users\\lifei\\AppData\\Local\\Programs\\Python\\Python36-32"
```
</details>


<details>
<summary>17. Как вставить объект, чтобы он оказался под определенным индексом?</summary>

Сначала создадим список:
```python
>>> a=[1, 2, 4]
```
Затем используем метод insert(). В нем первым аргументом будет индекс, под которым вставляется объект, а вторым — значение объекта:
```python
>>> a.insert(2,3)
>>> a
[1, 2, 3, 4]
```
</details>


<details>
<summary>18. Как можно обратить (reverse) порядок элементов в списке?</summary>

Для этого есть метод reverse():
```python
>>> a.reverse()
>>> a
[4, 3, 2, 1]
```
</details>


<details>
<summary>19. Что такое приглашение интерпретатора (interpreter prompt)?</summary>

Когда мы заходим в интерпретатор питона, то видим следующую строку:
```python
>>>
```
</details>


<details>
<summary>20. Что нужно сделать, чтобы функция возвратила значение?</summary>

Для этого используется ключевое слово return:
```python
>>> def add(a, b):
        return a + b
```
</details>


<details>
<summary>21. Что такое блок?</summary>

Когда мы пишем предложение (statement), нам нужно завершить первую строку двоеточием, а под ним написать блок кода, который исполняется в рамках этого предложения. Каждая строка блока пишется с одинаковым отступом.
```python
>>> if 3 > 1:
print("Hello")
print("Goodbye")
Hello
Goodbye
```
</details>


<details>
<summary>22. Зачем нужны break и continue?</summary>

Они используются для управления последовательностью операций: break останавливает исполнение цикла и переводит исполнение на следующий блок кода, continue как бы перепрыгивает на следующую итерацию цикла и не прекращает его исполнение.
</details>


<details>
<summary>23. Если мы не поставим двоеточие в конце строки для цикла "do-while", он все равно сработает?</summary>

В питоне такой цикл не реализован. Это вопрос из тех, которые с подвохом, когда упоминают элементы других языков.
</details>


<details>
<summary>24. Напишите в одну строку, как можно получить самую позднюю по значению букву в строке.</summary>

Значение буквы определяется по ее коду в ASCII. Для этого подойдет функция max():
```python
>>> max("flyiNg")
"y"
```
С помощью той же логики можно объяснить следующую строку кода:
```python
>>> max("fly{}iNg")
"}"
```
</details>


<details>
<summary>25. В каких областях питон имеет преимущество?</summary>

Лучше всего питон использовать в следующих областях:
 - веб-приложения
 - графические интерфейсы пользователя для настольных ПК
 - научные и арифметические приложения
 - разработка ПО
 - разработка программ обучения
 - приложения для бизнеса
 - сетевые приложения
 - игры, 3D-графика
</details>


<details>
<summary>26. Можете назвать десять встроенных функций питона?</summary>

Функция complex() создает комплексное число:
```python
>>> complex(3.5,4)
(3.5+4j)
```
Функция eval() исполняет строку:
```python
>>> eval("print(max(22,22.0) — min(2,3))")
20
```
Функция filter() отфильтровывает элементы, для которых заданное условие верно.
```python
>>> list(filter(lambda x: x%2 == 0,[1, 2, 0, False]))
[2, 0, False]
```
Функция format() помогает задать формат строки:
```python
>>> print("a = {0} but b = {1}".format(a, b))
a = 2 but b = 3
```
Функция hash() возвращает хэш-значение объекта:
```python
>>> hash(3.7)
644245917
```
Функция hex() преобразовывает число в шестнадцатеричное число:
```python
>>> hex(14)
"0xe"
```
Функция input() читает ввод и возвращает строку:
```python
>>> input("Enter a number")
Enter a number7
"7"
```
Функция len() возвращает число, показывающее длину строки:
```python
>>> len("Ayushi")
6
```
Функция locals() возвращает словарь с локальной таблицей имен:
```python
>>> locals()
{"__name__": "__main__", "__doc__": None, "__package__": None, "__loader__": <class "_frozen_importlib.BuiltinImporter">, "__spec__": None, "__annotations__": {}, "__builtins__": <module "builtins" (built-in)>, "a": 2, "b": 3}
```
Функция open() открывает файл:
```python
>>> file = open("tabs.txt")
```
</details>


<details>
<summary>27. Какой выход у следующего кода:</summary>

```python
>>> word = "abcdefghij"
>>> word[:3] + word[3:]
```
Выход: "abcdefghij".
</details>


<details>
<summary>28. Как конвертировать список в строку?</summary>

Для этого подойдет метод join():
```python
>>> nums=["one","two","three","four","five","six","seven"]
>>> s=" ".join(nums)
>>> s
"one two three four five six seven"
```
</details>


<details>
<summary>29. Как убрать из списка дубликат элемента?</summary>

Для этого можно конвертировать список во множество (set):
```python
>>> list = [1, 2, 1, 3, 4, 2]
>>> set(list)
{1, 2, 3, 4}
```
</details>


<details>
<summary>30. Можете объяснить жизненный цикл треда?</summary>

Общими словами, цикл выглядит так:
 - сначала создается класс, который подменяет метод исполнения класса в треде, и создаем экземпляр (instance) для этого класса;
 - вызываем start(), который готовит тред к исполнению;
 - переводим тред в состояние исполнения;
 - можно вызвать разные методы, например sleep() и join(), которые переводят тред в режим ожидания;
 - когда режим ожидания или исполнения прекращается, другие ожидающие треды подготавливаются к исполнению;
 - после завершения исполнения тред останавливается.
</details>


## Вопросы для собеседования / интервью о базовых аспектах программирования на питоне с ответами


<details>
<summary>31. Что такое словарь (dictionary)?</summary>

Словарь содержит пары типа "ключ: значение":
```python
>>> roots={25: 5, 16: 4, 9: 3, 4: 2, 1: 1}
>>> type(roots)
<class "dict">
>>> roots[9]
3
```
Словарь относится к изменяемым (mutable) объектам. Его можно создать с помощью:
 - литерала (символов {})
 - функции dict()
 - генератора (comprehension)
</details>


<details>
<summary>32. Расскажите про арифметические операторы //, %, и **.</summary>

Оператор // выполняет целочисленное деление и возвращает целую часть числа, полученного в результате операции:
```python
>>> 7 // 2
3
```
Оператор ** возводит в степень:
```python
>>> 2**10
1024
```
Оператор % возвращает результат деления по модулю, то есть остаток после деления:
```python
>>> 13%7
6
```
</details>


<details>
<summary>33. Что вам известно про операторы сравнения в питоне?</summary>

Данные операторы сравнивают значения между собой.

Оператор "меньше" (<): если значение с левой стороны от оператора меньше, он возвращает True:
```python
>>> "hi"<"Hi"
False
```
Оператор "больше" (>): если значение с левой стороны от оператора больше, он возвращает True:
```python
>>> 1.1+2.2>3.3
True
```
Оператор "меньше или равно" (<=): если значение с левой стороны от оператора меньше значения с правой стороны или равно ему, он возвращает True:
```python
>>> 3.0 <= 3
True
```
Оператор "больше или равно" (>=): если значение с левой стороны от оператора больше значения с правой стороны или равно ему, он возвращает True:
```python
>>> True >= False
True
```
Оператор равенства (==): если значения равны, он возвращает True:
```python
>>> {1,3,2,2} == {1,2,3}
True
```
Оператор неравенства (!=): если значения не равны, он возвращает True:
```python
>>> False != 0.1
True
```
</details>


<details>
<summary>34. Что такое операторы присвоения в питоне?</summary>

Все арифметические операторы можно комбинировать с символом присвоения.
```python
>>> a = 7
>>> a += 1
>>> a
8

>>> a -= 1
>>> a
7

>>> a *= 2
>>> a
14

>>> a /= 2
>>> a
7.0

>>> a **= 2
>>> a
49.0

>>> a // =3
>>> a
16.0

>>> a %= 4
>>> a
0.0
```
</details>


<details>
<summary>35. сскажите про логические операторы в питоне.</summary>

Всего их три: and, or, not.
```python
>>> False and True
False

>>> 7 < 7 or True
True

>>> not 2 == 2
False
```
</details>


<details>
<summary>36. Что такое оператор принадлежности?</summary>

Это операторы in и not in. Они показывают, является ли одно значение частью другого.
```python
>>> "me" in "disappointment"
True

>>> "us" not in "disappointment"
True
```
</details>


<details>
<summary>37. Расскажите про операторы тождественности.</summary>

Операторы is и is not показывают, являются ли два значения идентичными.
```python
>>> 10 is "10"
False

>>> True is not False
True
```
</details>


<details>
<summary>38. Что такое битовые операторы?</summary>

Данные операторы выполняют операции в битовом формате.
```python
>>> 0b110 & 0b010
2

>>> 3 | 2
3

>>> 3 ^ 2
1

>>> ~2
-3

>>> 1<<2
4

>>> 4>>2
1
```
</details>


<details>
<summary>39. Какие типы данных поддерживаются в питоне?</summary>

В питоне используется пять типов данных:
 - числа, которые содержат числовые значения;
 - строки, который представляют собой последовательность символов; обозначаются одинарными или двойными кавычками.
 - списки, который представляют собой коллекцию значений; обозначаются квадратными скобками.
 - кортежи, которые похожи на списки, но отличаются тем, что не могут быть изменены.
 - словари, которые содержат пары "ключ: значение"; обозначаются фигурными скобками.
</details>


<details>
<summary>40. Что такое строка документации (docstring)?</summary>

Она вносится первой строкой в блок, определяющий содержание функции, класса или метода. Содержит описание их цели и способа исполнения. Обозначается тремя одинарными или двойными кавычками с каждой стороны.
```python
>>> def sayhi():
        """
        The function prints Hi
        """
        print("Hi")

>>> sayhi()
Hi
```
Посмотреть ее содержание мы можем с помощью __doc__:
```python
>>> sayhi.__doc__
"\n\tThis function prints Hi\n\t"
```
В отличие от комментария строка документации читается во время исполнения.
</details>


<details>
<summary>41. Как можно конвертировать строку в число?</summary>

Если строка содержит только числовые символы, можно использовать функцию int():
```python
>>> int("227")
227
```
</details>


<details>
<summary>42. Как можно принять результат ввода на клавиатуре?</summary>

Если пользователь что-то вводит с помощью клавиатуры, можно использовать функцию input(). В качестве аргумента можно задать данной функции текст запроса на ввод. Результат ввода всегда является строкой.
```python
>>> a = input("Enter a number")
Enter a number7
```
</details>


<details>
<summary>43. Что такое функция?</summary>

Когда мы хотим исполнить определенную последовательность (sequence of statements), мы можем дать ей имя. Например, определим функцию, которая принимает два числа и возвращает то, которое больше.
```python
>>> def greater(a,b):
        return a is a>b else b
>>> greater(3,3.5)
3.5
```
</details>


<details>
<summary>44. Что такое рекурсия?</summary>

Это когда функция вызывает саму себя. При этом она должна иметь базовое условие, чтобы не создать бесконечный цикл:
```python
>>> def facto(n):
        if n == 1: return 1
        return n * facto(n - 1)
>>> facto(4)
24
```
</details>


<details>
<summary>45. Что делает функция zip()?</summary>

Возвращает итератор с кортежами:
```python
>>> list(zip(["a", "b", "c"],[1, 2, 3]))
[("a", 1), ("b", 2), ("c", 3)]
```
В данном случае она совмещает элементы двух списков и создает из них кортежи. Работает не только со списками.
</details>


<details>
<summary>46. Как посчитать длину строки (string)?</summary>

Для этого вызываем функцию len():
```python
>>> len("Ayushi Sharma")
13
```
</details>


<details>
<summary>47. Расскажите про генераторы списков (list comprehension).</summary>

Они позволяют создавать списки с помощью одной строки кода:
```python
>>> [i for i in range(1, 11, 2)]
[1, 3, 5, 7, 9]
```
</details>


<details>
<summary>48. Как можно получить все значения из словаря?</summary>

Для этого используется метод values()
```python
>>> 4 in {"a":1,"b":2,"c":3,"d":4}.values()
True
```
</details>


<details>
<summary>49. Как можно переключить регистр строки?</summary>

Можно использовать метод swapcase(), предусмотренный для класса str:
```python
>>> "AyuShi".swapcase()
"aYUsHI"
```
</details>


<details>
<summary>50. Возьмем строку "I love Python". Напишите код, который выведет символы до буквы "t".</summary>

```python
>>> s = "I love Python"
>>> i = 0
>>> while s[i] != "t":
        print(s[i], end="")
        i += 1
>>> I love Py
```
</details>


<details>
<summary>51. Возьмем строку "I love Python". Напишите код, который выведет эту строку без пробелов.</summary>

```python
>>> s = "I love Python"
>>> for i in s:
        if i == ' ': continue
        print(i, end='')
>>> IlovePython
```
</details>


<details>
<summary>52. Возьмем строку "I love Python". Напишите код, который выведет эту строку пять раз подряд.</summary>

```python
>>> s = "I love Python"
>>> for i in range(6):
        print(s)
>>> I love Python
>>> I love Python
>>> I love Python
>>> I love Python
>>> I love Python
```
</details>


<details>
<summary>53. Для чего используется bytes()?</summary>

Это встроенная функция питона, которая возвращает неизменяемый байтовый объект.
```python
>>> bytes([2,4,8])
b’\x02\x04\x08′

>>> bytes(5)
b’\x00\x00\x00\x00\x00′

>>> bytes('world','utf-8')
b’world’
```
</details>


<details>
<summary>54. Что такое оператор контроля последовательности (control flow statement)?</summary>

Обычно программа в питоне начинает исполнение с первой строки. После нее программа однократно исполняет каждое предложение. Когда будет исполнено последнее предложение, программа прекращается. Также контроль последовательности помогает усложнить обычный порядок исполнения программы.
</details>


<details>
<summary>55. Создайте новый лист с помощью конвертации списка числовых строк в список чисел.</summary>

```python
>>> nums = [‘22’, ’68’, ’110’, ’89’, ’31’, ’12’]
```
Теперь возьмем функцию int() и создадим генератор списка, который конвертирует строки в числа и внесет их в список:
```python
>>> [int(i) for i in nums]
[22, 68, 110, 89, 31, 12]
```
</details>


<details>
<summary>56. Как лучше всего хранить имена и фамилии наших работников?</summary>

Можно создать словарь, содержащий пары "ключ: значение":
```python
{"name": "Ayushi", "surname": "Sharma"}
```
</details>


## Топ вопросов по Python с ответами


<details>
<summary>57. Как работать с числами, которые не входят в десятичную систему счисления?</summary>

В питоне можно вводить бинарные, восьмеричные и шестнадцатеричные числа.

Бинарные. Это числа, составленные из 0 и 1. Для ввода в бинарном формате, используется префикс 0b или 0B:
```python
>>> int(0b1010)
10
```
Число можно преобразовать в бинарный формат с помощью функции bin():
```python
>>> bin(0xf)
‘0b1111’
```
Восьмеричные числа могут состоять из цифр от 0 до 7, также используется префикс 0o или 0O:
```python
>>> oct(8)
‘0o10’
```
Шестнадцатеричные числа могут состоять из цифр от 0 до 15, также используется префикс 0x или 0X:
```python
>>> hex(15)
‘0xf’
```
</details>


<details>
<summary>58. Какой результат выводит данный код:</summary>

```python
>>> def extendList(val, list=[]):
        list.append(val)
        return list
>>> list1 = extendList(10)
>>> list2 = extendList(123,[])
>>> list3 = extendList('a')
>>> list1, list2, list3
[10, ‘a’], [123], [10, ‘a’]
```
Возможный, но неверный ответ: ([10], [123], [‘a’])

В функции есть аргумент list=[], который не запускается в нулевом значении при каждом вызове этой функции. Когда мы первый раз определяем функцию, она создает новый список. Затем, каждый раз, когда мы вызываем данную функцию без аргумента-списка, она использует один и тот же список. Питон исполняет выражения, которые имеют нулевые значения, при определении функции, а не при вызове функции.
</details>


<details>
<summary>59. Сколько аргументов может принять range()?</summary>

От одного до трех:
```python
>>> list(range(5))
[0, 1, 2, 3, 4]
>>> list(range(-5))
[]
>>> list(range(2, 7))
[2, 3, 4, 5, 6]
>>> list(range(-3, 4))
[-3, -2, -1, 0, 1, 2, 3]
>>> list(range(2, 9, 2))
[2, 4, 6, 8]
>>> list(range(9, 2, -1))
[9, 8, 7, 6, 5, 4, 3]
```
</details>


<details>
<summary>60. Что такое РЕР8?</summary>

Это соглашение о программировании в питоне, которое содержит рекомендации для повышения читаемости кода.
</details>


<details>
<summary>61. Чем Python отличается от Java?</summary>

Если сравнивать Python и Java:
 - Java быстрее
 - Python использует отступы, а Java нужны скобки
 - в Python динамическая типизация, а в Java — статическая
 - Python — простой и лаконичный, а Java — многословный язык
 - Python — интерпретируемый язык
 - Java не зависит от используемой платформы
 - в Java есть интерфейс JDBC, который улучшает доступ к базам данных
</details>


<details>
<summary>62. Как лучше всего поменять местами числовые значения объектов?</summary>

```python
>>> a, b = b, a
```
Как выполняется этот код:
```python
>>> a, b = 2, 3
>>> a, b = b, a
>>> a, b
(3, 2)
```
</details>


<details>
<summary>63. Как можно выполнить несколько операций присвоения в одном предложении?</summary>

Первый способ (несколько объектов с уникальными значениями):
```python
>>> a, b, c = 3, 4, 5
```
Второй способ (несколько объектов с идентичными значениями):
```python
>>> a = b = c = 3
```
</details>


<details>
<summary>64. Как выйти из бесконечного цикла?</summary>

Можно нажать комбинацию клавиш Ctrl+C, которая прерывает исполнение.
</details>


## Технические вопросы для собеседования / интервью по Python с ответами


<details>
<summary>65. Как исполняется код в питоне?</summary>

Файлы питона сначала компилируются в байткод, который затем исполняется.
</details>


<details>
<summary>66. Расскажите, какой в питоне механизм передачи параметров.</summary>

В питоне используется передача параметров по ссылке. Если изменить параметр внутри функции, то это отразится на выводе функции. Однако, если использовать в качестве параметров литералы (строки, числа, кортежа), то они передаются по значению (потому что они не изменяемые).
</details>


<details>
<summary>67. Что такое with в питоне?</summary>

Данная инструкция обеспечивает исполнение кода очистки после исполнения программы. Например, можно использовать ее для открытия файла, совершить с ним какие-то действия и автоматически закрыть файл после завершения работы. Аналогичным образом можно открывать соединение с базой данных и автоматически его закрывать. Код очистки исполняется даже в случае, когда появляется исключение (exception).
```python
>>> with open('data.txt') as data:
        # исполняемый блок
```
</details>


<details>
<summary>68. Чем файл .pyc отличается от .py?</summary>

Оба файла содержат байткод, но .pyc является компилированной версией файла питона. Его байткод не зависит от платформы, поэтому он исполняется на всех платформах, которые поддерживают формат .pyc.
</details>


<details>
<summary>69. Что делает питон объектно-ориентированным?</summary>

Он следует парадигме объектно-ориентированного программирования, которая построена вокруг классов (classes) и их экземпляров (instances). Это позволяет реализовать следующие функции:
 - сокрытие внутренней структуры данных
 - абстракция
 - наследование
 - полиморфизм (способность выбирать правильный метод в зависимости от типа данных)
 - ограничение доступа к данным
</details>


<details>
<summary>70. Какие есть типы объектов в питоне?</summary>

В питоне поддерживаются изменяемые (mutable) и не изменяемые (immutable) типы объектов.

Не изменяемые не позволяют изменять свое содержание. Примеры: кортежи, булевы, строки, числа. Итерация по ним выполняется быстрее.

Изменяемые позволяют изменять свое содержание. Примеры: списки, множества и словари. Итерация по ним выполняется медленнее.
</details>


# С опытом работы


<details>
<summary>71. Когда в блоке try-except исполняется элемент else?</summary>

В блоке `if-else` элемент `else` исполняется в случае, если условие в операторе `if (if statement)` является неверным (`False`). А вот в блоке `try-except` элемент `else` исполняется только в случае, если элемент `try` не выдает исключение.
</details>


<details>
<summary>72. Допустим, есть список nums=[0,1,2,3,4]. Что означает nums[-1]?</summary>

Данный код не будет выдавать исключение. `nums[-1]` — это 4, потому что движение по элементам начинается справа.
</details>


<details>
<summary>73. Что такое переменная PYTHONPATH?</summary>

PYTHONPATH — эта переменная сообщает интерпретатору путь до файлов модуля, импортированных в программу. Поэтому она должна включать в себя директорию с библиотекой-источником питона и директории с исходным кодом питона. Переменную PYTHONPATH можно назначить самостоятельно, однако обычно ее предустанавливает установщик питона.
</details>


<details>
<summary>74. Расскажите про функции join() и split() в Python.</summary>

Функция `join()` позволяет соединять символы строки (string), чередуя с указанным символом.
```python
>>> ','.join('12345')
‘1,2,3,4,5’
```
Функция `split()` позволяет разделить строку, чередуя символы с указанным символом.
```python
>>> '1,2,3,4,5'.split(',')
[‘1’, ‘2’, ‘3’, ‘4’, ‘5’]
```
</details>


<details>
<summary>75. Расскажите, какая будет выдача у этого кода:</summary>

```python
x=[‘ab’,’cd’]
print(len(map(list,x)))
```
Здесь будет ошибка определения типа (`TypeError`). Ее причиной является отсутствие атрибута `len()` у функции `map()`. Это можно проверить функцией `dir()`.
</details>


<details>
<summary>76. Приведите несколько методов, с помощью которых можно реализовать в питоне функционально ориентированное программирование.</summary>

Несколько методов могут помочь с итерацией по списку (list).

1. `filter()` может отфильтровать несколько значений на основе условия.
    ```python
    >>> list(filter(lambda x:x>5,range(8)))
    [6, 7]
    ```
2. `map()` применяет функцию к каждому элементу итерируемого объекта.
    ```python
    >>> list(map(lambda x:x**2,range(8)))
    [0, 1, 4, 9, 16, 25, 36, 49]
    ```
3. `reduce()` продолжает уменьшать последовательность (sequence) парами, пока не будет достигнуто единичное значение.
    ```python
    >>> from functools import reduce
    >>> reduce(lambda x,y:x-y,[1,2,3,4,5])
    -13
    ```
</details>


<details>
<summary>77. И все-таки, какая выдача у этого кода:</summary>

```python
x=[‘ab’,’cd’]
print(len(list(map(list,x))))
```

Здесь на выходе ‘2’, потому что длина этого списка составляет два элемента. Выдача у `list(map(list,x))` будет `[[‘a’, ‘b’], [‘c’, ‘d’]]`, а в этом списке два элемента.
</details>


<details>
<summary>78. Можно ли сказать, что del и remove() — это одно и то же? Что это такое, в целом?</summary>

del и remove() — это методы для списков, они нужны для удаления элементов.
```python
>>> list=[3,4,5,6,7]
>>> del list[3]
>>> list
[3, 4, 5, 7]
```
```python
>>> list.remove(5)
>>> list
[3, 4, 7]
```

`del` позволяет удалять элементы под конкретным индексом, а `remove()` позволяет удалять элементы на основе их значения.
</details>


<details>
<summary>79. Как нужно открывать файл для записи?</summary>

Допустим, есть файл tabs.txt. Чтобы открыть его и записывать в него, необходим такой код:
```python
>>> file=open('tabs.txt','w')
```
Теперь файл открылся в режиме записи. После завершения работы файл нужно закрыть.
```python
>>> file.close()
```
</details>


<details>
<summary>80. Объясните, почему у следующего кода такая выдача:</summary>

```python
>>> tuple=(123,'John')
>>> tuple*=2
>>> tuple
(123, ‘John’, 123, ‘John’)
```
В этом коде кортеж (tuple) умножается на 2. Поэтому его содержимое удваивается. То есть, на выходе мы получим (123, ‘John’, 123, ‘John’). Со строками тоже можно так сделать:
```python
>>> 'ba'+'na'*2
‘banana’
```
</details>


<details>
<summary>81. Какие различия есть между методами для списков append() и extend()?</summary>

Метод append() добавляет элемент к концу списка, а метод extend() добавляет к концу списка переданный ему итерируемый объект (iterable). Возьмем два списка.
```python
>>> list1, list2 = [1, 2, 3], [5, 6, 7, 8]
```
Вот так действует append():
```python
>>> list1.append(4)
>>> list1
[1, 2, 3, 4]
```
А вот так действует extend():
```python
>>> list1.extend(list2)
>>> list1
[1, 2, 3, 4, 5, 6, 7, 8]
```
</details>


<details>
<summary>82. Какие есть режимы обработки файлов в Python?</summary>

Предусмотрены следующие режимы:

 - только чтение – ‘r’
 - только запись – ‘w’
 - чтение-запись – ‘rw’
 - добавление в конце – ‘a’

Можно открыть текстовый файл с опцией ‘t’. Поэтому, чтобы открыть текстовый файл для чтения, можно использовать режим ‘rt’. Точно так же для бинарных файлов используется ‘b’.
</details>


<details>
<summary>83. Что делает функция map()?</summary>

Функция `map()` возвращает итератор, который применяет функцию, переданную ей в первом аргументе, ко всем элементам итерируемого объекта (iterable), переданного ей во втором аргументе. Можно показать пример?
```python
>>> for i in map(lambda i:i**3, (2,3,7)):
    ....print(i)
8
27
343
```
На выходе – элементы 2, 3, 7, возведенные в куб.
</details>


<details>
<summary>84. Расскажите про try, raise и finally.</summary>

Это ключевые слова (keywords) для обработки исключений (exception handling). Потенциально рискованный код помещается в блок `try`, оператор `raise` (raise statement) используется для прямого вызова ошибки, а в блоке `finally` находится код, который исполняется в любом случае.
</details>


<details>
<summary>85. Что случится, если не обработать ошибку в блоке except?</summary>

Если этого не сделать, программа завершится. Затем она отправит трассу исполнения на sys.stderr.
</details>


<details>
<summary>86. Есть ли возможность удалить последний объект списка?</summary>

Да, такая возможность предусмотрена. Можно попробовать такой вариант:
```python
>>> list=[1,2,3,4,5
>>> list.pop(-1)
5
>>> list
[1, 2, 3, 4]
```
</details>


<details>
<summary>87. Как можно преобразовать целое число (integer) в символ Unicode?</summary>

Для этого просто нужна встроенная функция chr(x). Можно показать?
```python
>>> chr(52)
‘4’
>>> chr(49)
‘1’
>>> chr(67)
‘C’
```
</details>


<details>
<summary>88. Объясните, какая проблема с этим кодом:</summary>

```python
>>> def func(n=[]):
    ....# playing around
    ....pass
>>> func([1,2,3])
>>> func()
>>> n
```
В результате запроса n появляется ошибка присвоения названия (NameError), потому что n является локальной переменной функции func. В другом месте она недоступна. Также Python определяет значения параметров по умолчанию только один раз, поэтому каждый вызов функции использует то же значение по умолчанию. Если во время какого-то вызова будет изменено значение по умолчанию, то в следующем вызове будет использовано новое значение.
</details>


<details>
<summary>89. Что здесь написано?</summary>

```python
s = a + ‘[’ + b + ‘:’ + c + ‘]’
```
Здесь выполняется сцепление строк (string concatenation). Если a, b и c являются строками (strings), то все пройдет нормально, они будут сцеплены со строками ‘[’, ‘:’ и ‘]’. Однако, если хотя бы один из элементов сцепления не является строкой, то появится ошибка TypeError.
</details>


<details>
<summary>90. Может ли рекурсия создавать сложности?</summary>

Разумеется:

 - Приходится чаще вызывать функцию.
 - Каждый вызов функции сохраняет переменную состояния в программном стеке, то есть растет потребление памяти, что в итоге может стать причиной переполнения памяти.
 - Вызовы функции отнимают время.
</details>


<details>
<summary>91. Какие преимущества у рекурсии?</summary>

Рекурсия помогает:

 - экономить усилия на выполнение задачи,
 - сократить объем кода по сравнению с циклами,
 - легче воспринимать код.
</details>


<details>
<summary>92. Какой выход у этого кода?</summary>

```python
>>> b=(1)
```
На выходе не будет кортежа (tuple). Мы получим обычное целое число.
```python
>>> type(b)
```
Чтобы получить кортеж, мы можем добавить прямую декларацию с помощью запятой после числа 1:
```python
>>> b=(1,)
>>> type(b)
```
</details>


<details>
<summary>93. Почему игнорируются имена-идентификаторы, которые начинаются с символа подчеркивания?</summary>

В питоне не реализована концепция скрытой переменной (private variable), поэтому принято декларировать скрытые переменные первым символом в виде нижнего подчеркивания.
</details>


<details>
<summary>94. Можно ли удалить пробелы из строки (string) “aaa bbb ccc ddd eee”?</summary>

Я вспомнил три способа.

Функция join():
```python
>>> s='aaa bbb ccc ddd eee'
>>> s1=''.join(s.split())
>>> s1
‘aaabbbcccdddeee’
```
Генератор списка (list comprehension):
```python
>>> s='aaa bbb ccc ddd eee'
>>> s1=str(''.join(([i for i in s if i!=' '])))
>>> s1
‘aaabbbcccdddeee’
```
Функция replace():
```python
>>> s='aaa bbb ccc ddd eee'
>>> s1 = s.replace(' ','')
>>> s1
‘aaabbbcccdddeee’
```
</details>


<details>
<summary>95. Как узнать текущую директорию в питоне?</summary>

Чтобы узнать, в какой директории мы сейчас находимся, можно использовать метод getcwd() из модуля os module.
```python
>>> import os
>>> os.getcwd()
‘C:\\Users\\Ayushi\\AppData\\Local\\Programs\\Python\\Python37-32’
```
</details>


<details>
<summary>96. Как можно перемешать в случайном порядке (рандомизировать) содержание списка (list) путем его изменения?</summary>

Для этого можно импортировать функцию shuffle() из модуля random.
```python
>>> from random import shuffle
>>> shuffle(mylist)
>>> mylist
[3, 4, 8, 0, 5, 7, 6, 2, 1]
```
</details>


<details>
<summary>97. Если строка (string) начинается с пробела, как его убрать?</summary>

Такой пробел можно убрать с помощью метода lstrip().
```python
>>> ' Ayushi '.lstrip()‘
‘Ayushi '
```
В этой строке пробелы стояли как в начале, так и в конце. Функция lstrip() убрала крайний слева пробел из строки. Если мы захотим убрать пробел из хвоста, то воспользуемся функцией rstrip().
```python
>>> ' Ayushi '.rstrip()
‘ Ayushi’
```
</details>


<details>
<summary>98. Сейчас мы покажем код, в котором нужно удалить числа меньше 5 из списка (list) nums. Однако, ожидаемого эффекта он не дает. Можете показать нам, где баг?</summary>

```python
>>> nums=[1,2,5,10,3,100,9,24]
>>> for i in nums:
    ....if i<5:
    ........nums.remove(i)
>>> nums
[2, 5, 10, 100, 9, 24]
```
В данном коде проверяется каждый элемент списка nums, т.е. окажется ли он меньше 5. Если условие выполняется, то данный элемент будет удален. На первой итерации, действительно, оказывается, что 1 меньше 5, поэтому данный элемент удаляется из списка. Однако данное действие вносит путаницу в индексы элементов, поэтому программа проверяет элемент 5, а не элемент 2. Решить данную проблему можно тремя способами:

Можно создать пустой массив и добавлять элементы с конца (append):
```python
>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=[]
>>> for i in nums:
    ....if i>=5:
    ........newnums.append(i)
>>> newnums
[5, 10, 100, 9, 24]
```
Можно воспользоваться генератором списка (list comprehension):
```python
>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=[i for i in nums if i>=5]
>>> newnums
[5, 10, 100, 9, 24]
```
Можно воспользоваться функцией filter():
```python
>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=list(filter(lambda x:x>=5, nums))
>>> newnums
[5, 10, 100, 9, 24]
```
</details>


<details>
<summary>99. Что за функция enumerate() в Python?</summary>

Функция enumerate() осуществляет итерацию вдоль последовательности (sequence), извлекает индекс и его значение.

Посмотрим на примере.
```python
>>> for i,v in enumerate(['Python','C++','Scala']):
    ....print(i,v)
0 Python
1 C++
2 Scala
```
</details>


<details>
<summary>100. Как можно создать такой паттерн в питоне?</summary>

```
*
**
***
****
*****
```
Можно использовать два цикла for (for-loops).
```python
>>> for i in range(1,6):
    ....for j in range(1,i+1):
    ........print('*',end='')
    ....print()
```
</details>


<details>
<summary>101. В каком случае while уместнее, чем for?</summary>

В целом, for подойдет во всех случаях, когда применим while, однако есть несколько ситуаций, когда с циклом while проще:

 - Простые повторяющиеся циклы
 - Когда не нужно осуществлять итерацию вдоль списка элементов (например, записи в базе данных и символы строки.
</details>


<details>
<summary>102. Посмотрим на вот такой код:</summary>

```python
>>> A0=dict(zip(('a','b','c','d','e'),(1,2,3,4,5)))
>>> A1=range(10)
>>> A2=sorted([i for i in A1 if i in A0])
>>> A3=sorted([A0[s] for s in A0])
>>> A4=[i for i in A1 if i in A3]
>>> A5={i:i*i for i in A1}
>>> A6=[[i,i*i] for i in A1]
>>> A0,A1,A2,A3,A4,A5,A6
```
Какие будут значения у переменных с A0 по A6? Объясните свой ответ.

Результат будет следующий:
```python
A0={‘a’: 1, ‘b’: 2, ‘c’: 3, ‘d’: 4, ‘e’: 5}
A1=range(0, 10)
A2=[]
A3=[1, 2, 3, 4, 5]
A4=[1, 2, 3, 4, 5]
A5={0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
A6=[[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]
```
Теперь посмотрим, что тут произошло. A0 сцепляет ‘a’ с 1, ‘b’ с 2 и т.д. с помощью функции zip(). Создаются кортежи (tuples), которые затем передаются функции dict() и преобразовываются в словарь, в котором ключами (keys) и значениями (values) являются элементы кортежей.

A1 создает объект range, который начинается на start=0 и заканчивается на stop=10.

A2 проверяет каждый элемент в A1 на его присутствие в A0. Если ответ утвердительный, элемент добавляется в список (list). Затем этот список упорядочивается (сортируется) с помощью sorted(). Поскольку нет ни одного элемента, присутствующего и в A0, и в A1, на выходе получаем пустой список.

A3 берет каждый ключ в A0 и возвращает его значение. В итоге мы получаем список [1,2,3,4,5].

A4 проверяет каждый элемент A1 на его присутствие в A3. Если ответ утвердительный, элемент добавляется в список, который мы получаем на выходе.

A5 возводит каждый элемент A1 в квадрат и возвращает словарь (dictionary), в котором ключами являются элементы A1 и они же, возведенные в квадрат, являются значениями.

A6 берет каждый элемент A1 и возвращает вложенные списки (sublists) с этими элементами и их квадратами. По одному.
</details>


<details>
<summary>103. Есть ли в питоне оператор переключения (switch-case statement)?</summary>

В питоне такого оператора нет, но можно написать функцию для реализации этого функционала. Как вариант, можно использовать набор операторов if-elif-else. В такой функции может использоваться словарь (dictionary).
```python
>>> def switch(choice):
    ....switcher={'Ayushi':'Monday', 'Megha':'Tuesday'}
    ....print(switcher.get(choice,'Hi, user'))
>>> switch('Megha')
Tuesday
>>> switch('Ayushi')
Monday
>>> switch('Ruchi')
Hi, user
```
В этом примере метод get() возвращает значение (value) для ключа (key). Если нет нужного ключа, возвращается значение, заданное по умолчанию (второй аргумент метода get()).
</details>


<details>
<summary>104. Объясните разницу между полной копией (deep copy) и поверхностной копией (shallow copy).</summary>

Полное копирование создает новый объект-копию. То есть, если внести изменение в копию объекта, то с первоначальным объектом ничего не случится. В Python для этого используется функция deepcopy() с помощью импорта из модуля copy.
```python
>>> b=copy.copy(a)
```
Поверхностная копия копирует на новый объект ту ссылку, которая закреплена на первоначальном объекте. Поэтому если внести изменение в копию, то оно распространится на первоначальный объект. Данный функционал реализуется с помощью функции copy().
```python
>>> b=copy.copy(a)
```
</details>


<details>
<summary>105. Можно ли создать локальную переменную (local variable), имя которой начинается с символа нижнего подчеркивания?</summary>

Можно, но не рекомендуется. Локальными переменными обозначаются скрытые переменные (private variables) класса, поэтому такое действие запутает интерпретатора (interpreter).
</details>


<details>
<summary>106. Можно ли сказать, что массив (array) NumPy лучше списка (list)?</summary>

Массивы NumPy имеют три преимущества перед списками:

 - Они быстрее
 - Они потребляют меньше памяти
 - С ними удобнее работать
</details>


<details>
<summary>107. Если установить модуль с помощью pip, но импортировать его в интегрированную среду разработки (IDLE) не получается. В чем может быть причина?</summary>

 - Возможно, в системе установлена более чем одна версия питона. Например 32- и 64-битную.
 - Переменная пути (Path variable) в списке переменных системного окружения (system environment variable) может быть назначена на обе версии, но с приоритетом одной из них, например 32-битной.
 - Получается, что, включая приглашение командной строки (command prompt), я использую 32-битную версию pip для установки модуля.
 - При запуске интегрированной среды разработки используеются 64-битная версия.

Если все произойдет вот так, то импортировать установленный модуль не получится.
</details>


<details>
<summary>108. Отталкиваясь от предыдущего вопроса и ответа, как можно решить данную проблему?</summary>

Есть два варианта.

1. Временное решение. Можно добавлять путь вручную через sys перед каждым включением новой сессии интерпретатора (interpreter).
    ```python
    >>> sys.path.append('C:\\Users\\Ayushi\\AppData\\Local\\Programs\\Python\\Python37\\Scripts')
    ```
2. Постоянное решение. Обновить значение Path в переменных окружения, чтобы папка Scripts 64-битной версии была первой.
</details>


<details>
<summary>109. Допустим, во время установки пакета (package) с помощью pip появляется ошибка "No matching installation found" (Подходящей установки не обнаружено). Что здесь можно сделать?</summary>

В такой ситуации можно, как вариант, загрузить исполняемые файлы пакета.
</details>


<details>
<summary>110. Как можно отслеживать разные версии кода?</summary>

Для этого используется контроль версий (version control). Одним из возможных инструментов контроля является Git.
</details>


<details>
<summary>111. Как можно провести отладку (debug) программы в Python? Дайте короткий ответ.</summary>

Для отладки в Python используется модуль pdb, отладчик (debugger) Python. Если запустить программу с pdb, то мы сможем пройти по коду пошагово.
</details>


<details>
<summary>112. Можно ли осуществить динамическую загрузку модуля в Python?</summary>

При динамической загрузке модули загружаются только когда они становятся нужны. Такой подход — медленный, но он помогает эффективнее использовать память. В Python для этого можно использовать модуль importlib:
```python
import importlib
module = importlib.import_module('my_package.my_module')
```

</details>


<details>
<summary>113. Какие методы/функции мы используем для определения типа экземпляра (type of instance) и наследования (inheritance)?</summary>

Для этого используются type(), isinstance() и issubclass().

1. type() используется для определени типа объекта.
    ```python
    >>> type(3)
    >>> type(False)
    >>> type(lambda :print("Hi"))
    >>> type(type)
    ```
2. isinstance() принимает два аргумента: значение (value) и тип (type). Если значение относится к соответствующему типу, то возвращается True. Если нет, то возвращается False.
    ```python
    >>> isinstance(3,int)
    True
    >>> isinstance((1),tuple)
    False
    >>> isinstance((1,),tuple)
    True
    ```
3. issubclass() принимает два класса (classes) в качестве аргументов (arguments). Если второй наследует из первого, то возвращается True. Если нет, то возвращается False.
    ```python
    >>> class A: pass
    >t; class B(A): pass
    >>> issubclass(B,A)
    True
    >>> issubclass(A,B)
    False
    ```
</details>


<details>
<summary>114. Методы (methods) и конструкторы (constructors) — это одно и то же или нет?</summary>

Разница между ними очень тонкая, но важная:

 - Название конструктора должно соответствовать названию класса, а метод можно называть как угодно.
 - Конструктор исполняется при создании объекта, а метод исполняется при его вызове.
 - Конструктор исполняется один раз для каждого объекта, а метод можно вызывать по одному объекту неограниченно.
 - Конструкторы используются для определения (define) и инициализации не статических переменных. Методы используются для осуществления операций в рамках бизнес-логики.
</details>


<details>
<summary>115. Что понимается под модулем в питоне?</summary>

Модуль — это скрипт, в котором определяются операторы импорта (import statements), функции (functions), классы (classes) и переменные (variables). Файлы ZIP и DLL тоже могут быть модулями. Название модуля хранится в глобальной переменной (global variable) в виде строки (string).
</details>


<details>
<summary>116. Какие в питоне есть модули для работы с файлами?</summary>

Питон предлагает следующие библиотеки и модули для обработки текстов и двоичных файлов:

`os` 
`os.path` 
`shutil`
</details>


<details>
<summary>117. Можете коротко объяснить, как используются модули sqlite3, ctypes, pickle, traceback и itertools.</summary>

 - sqlite3 помогает обрабатывать базы данных, например SQLite
 - ctypes позволяет создавать в питоне типы данных из Си и обрабатывать их
 - pickle позволяет переносить любые структуры данных во внешние файлы
 - traceback позволяет извлекать, форматировать и выводить на печать трассы вызовов (stack traces)
 - itertools помогает работать с перестановками (permutations), комбинациями (combinations) и другими итерируемыми объектами (iterables).
</details>


<details>
<summary>118. Расскажите про наследование (inheritance) в Python.</summary>

Когда один класс наследует из другого, его называют дочерним/производным/подклассом (child/derived/sub class), который наследует из родительского/базового/супер класса (parent/base/super class). Он наследует/получает все атрибуты и методы.

Наследование позволяет повторно использовать код и облегчает создание и дальнейшую работу приложений (applications). В Python поддерживаются следующие виды наследования:

 - Единичное наследование (Single Inheritance) — класс наследует из одного базового класса.
 - Множественное наследование (Multiple Inheritance) — класс наследует из двух или нескольких базовых классов.
 - Многоуровневое наследование (Multilevel Inheritance) — класс наследует из базового класса, который, в свою очередь, наследует из другого базового класса.
 - Иерархическое наследование (Hierarchical Inheritance) — два класса или несколько классов наследуют из одного базового класса (single base class).
 - Гибридное наследование (Hybrid Inheritance) — сочетание двух или нескольких видов наследования.
</details>


<details>
<summary>119. Объясните, как в Python осуществляется управление памятью.</summary>

В Python объекты и структуры данных (data structures) находятся в закрытой динамически выделяемой области (private heap), которая управляется менеджером памяти Python. Он делегирует часть работы программам распределения ресурсов (allocators), закрепленным за конкретными объектами, и одновременно с этим следит, чтобы они не выходили за пределы динамически выделяемой области. По факту данной областью управляет интерпретатор (interpreter). Пользователь никак не контролирует данный процесс, даже когда манипулирует ссылками объектов на блоки памяти внутри динаической области. Менеджер памяти Python распределяет пространство динамической области среди объектов и другие внутренние буферы по требованию.
</details>


<details>
<summary>120. Напишите программу на питоне, которая посчитает количество заглавных букв в файле.</summary>

```python
>>> import os
>>> os.chdir('C:\\Users\\lifei\\Desktop')
>>> with open('Today.txt') as today:
    ....count=0
>>> for i in today.read():
    ....if i.isupper():
    ........count+=1
    ....print(count)
26
```
</details>


<details>
<summary>121. Как можно сделать скрипт Python, исполняемый в Unix?</summary>

Для этого должны выполняться два условия:

 - Файл скрипта должен быть в исполняемом режиме.
 - Первая строка должен начинаться с решетки (хэша, hash(#)), например: #!/usr/local/bin/python
</details>


<details>
<summary>122. Какие функции или методы можно использовать для удаления файла в Python?</summary>

Для этого можно использовать remove() или unlink().
```python
>>> import os
>>> os.chdir('C:\\Users\\lifei\\Desktop')
>>> os.remove('try.py')
>>>
>>> os.unlink('try.py')
>>>
```
Обе функции делают одно и то же, просто unlink — это традиционное название в Unix.
</details>


<details>
<summary>123. Можете написать функцию для генерации такой пирамиды?</summary>

```
*
***
*****
*******
*********
```
```python
def pyramid(n):
    for row in range(n):
        for space in range(n-row):
            print(' ',end='')
    for star in range(row):
        print('*',end='')
    for star in range(row+1):
        print('*',end='')
    print()

pyramid(5)
```
</details>


<details>
<summary>124. Как можно вывести на печать содержимое файла?</summary>

```python
>>> try:
    ....with open('tabs.txt','r') as f:
    ........print(f.read())
    except IOError:
    ........print("File not found")
```
</details>


<details>
<summary>125. Расскажите про выражения лямбда (lambda expressions). Где они могут пригодиться?</summary>

Если нужно написать функцию с одним выражением, то можно обойтись без определения и сделать ее анонимной. Выражение лямбда может принимать входные данные и возвращать значения. Пример функции, представленной в виде выражения лямбда:
```python
>>> (lambda a,b:a if a>b else b)(3,3.5)
3.5
```
В данном примере входные данные обозначаются переменными a и b. То есть, если a > b, то возвращается a, в противном случае возвращается b. В качестве аргументов используются 3 и 3.5.

Лямбда позволяет обойтись без входных данных.
```python
>>> (lambda :print("Hi"))()
Hi
```
</details>


<details>
<summary>126. Что такое генератор (generator)?</summary>

В питоне генератор создает последовательность (sequence) значений, вдоль которой осуществляется итерация. То есть, это своего рода итерируемый объект (iterable). Мы пишем функцию, которая выдает (yield) значения по одному, а затем используем цикл for (for loop) для итерации вдоль нее.
```python
>>> def squares(n):
    ....i=1
    ....while(i<=n):
    ........yield i**2
    ....i+=1

>>> for i in squares(7):
    ....print(i)
1
4
9
16
25
36
49
```
</details>


<details>
<summary>127. Ну тогда, что такое итератор (iterator)?</summary>

Итератор возвращает один объект за раз во время цикла итерации. Для создания итератора можно использовать функцию `iter()`.
```python
odds=iter([1,3,5,7,9])
```
Затем мы отправляем его в функцию `next()` каждый раз, когда хотим получить объект.
```python
>>> next(odds)
1
>>> next(odds)
3
>>> next(odds)
5
>>> next(odds)
7
>>> next(odds)
9
```
Но при следующем вызове появится исключение остановки итерации (`StopIteration exception`), потому что закончили значения, по которым можно осуществлять итерацию.
```python
>>> next(odds)
Traceback (most recent call last):
File “<pyshell#295>”, line 1, in
next(odds)
StopIteration
```
</details>


<details>
<summary>128. Хорошо, мы спросили вас про генераторы (generators) и итераторы (iterators), и вы дали верные ответы. Но ведь они звучат очень похоже?</summary>

Так и есть, но между ними существуют тонкие различия:

 - Для генератора мы написали функцию, а для итератора можно использовать встроенные функции iter() и next().
 - Для генератора используется ключевое слово yield для выдачи по одному объекту за раз.
 - В генераторе может быть сколько угодно операторов yield.
 - Генератор сохраняет текущее состояние локальных переменных (local variables) каждый раз, когда yield приостанавливает цикл (loop). Итератор не использует локальные переменные, он работает только с итерируемым объектом (iterable).
 - Итератор можно использовать с помощью класса, а генератор — нет.
 - Генераторы работают быстро, компактно и проще.
 - Итераторы экономнее потребляют память.
</details>


<details>
<summary>129. Что такое декоратор (decorator)?</summary>

Функция, которая расширяет другую функцию без внесения в нее изменений, оборачиваясь (wrap) вокруг нее. Посмотрим на примере.
```python
>>> def decor(func):
    ....def wrap():
    ........print("$$$$$$$$$$$$$$$$$")
    ........func()
    ........print("$$$$$$$$$$$$$$$$$")
```
Декораторы — из сферы метапрограммирования (metaprogramming), в котором одна часть кода пытается изменить другую.
</details>


<details>
<summary>130. Что такое временная подмена (Monkey Patching)?</summary>

Она модифицирует класс или модуль во время выполнения (at runtime), то есть представляет собой динамическую модификацию (dynamic modification). Пример:
```python
from pkg.module import MyClass

def sayhello(self):
    print("Hello")

MyClass.sayhello=sayhello
```
</details>


## Свободные вопросы, не связанные с техническими знаниями о Python.

Также следует быть готовым к вопросам на свободные темы, с помощью которых интевьюер хочет узнать получше ваш характер и ваши мотивации. Несколько примеров таких вопросов см. далее.


<details>
<summary>131. Почему мы должны взять именно вас?</summary>
</details>


<details>
<summary>132. В чем вы выросли как личность после ухода с последнего места?</summary>
</details>


<details>
<summary>133. Расскажите про какую-нибудь ситуацию на прошлой работе, когда возникли сложности. Как вы их решили?</summary>
</details>


<details>
<summary>134. Как бы вы урегулировали спор с коллегой? Возникали ли такие ситуации на прошлой работе?</summary>
</details>


<details>
<summary>135. В чем бы вы хотели, чтобы мы были лучше по сравнению с прошлым работодателем?</summary>
</details>


<details>
<summary>136. Удавалось ли вам когда-нибудь изменить чью-то позицию по рабочему вопросу?</summary>
</details>


<details>
<summary>137. Что думаете про обмен слухами среди коллег?</summary>
</details>


<details>
<summary>138. В чем ваше слабое место с точки зрения работы?</summary>
</details>


<details>
<summary>139. Как вы думаете, в каком направлении будет развиваться отрасль в следующие 15 лет?</summary>
</details>


<details>
<summary>140. Что вы оставили после себя на прошлой работе? Удалось ли вам развить инновационное решение?</summary>
</details>


<details>
<summary>141. Как бы вы предпочли работать, самостоятельно или в небольшой/крупной группе?</summary>
</details>
